// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"go.dtapp.net/golog/internal/ent/ginlog"
	"go.dtapp.net/golog/internal/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiLog   = "ApiLog"
	TypeGinLog   = "GinLog"
	TypeHertzlog = "Hertzlog"
)

// ApiLogMutation represents an operation that mutates the ApiLog nodes in the graph.
type ApiLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApiLog, error)
	predicates    []predicate.ApiLog
}

var _ ent.Mutation = (*ApiLogMutation)(nil)

// apilogOption allows management of the mutation configuration using functional options.
type apilogOption func(*ApiLogMutation)

// newApiLogMutation creates new mutation for the ApiLog entity.
func newApiLogMutation(c config, op Op, opts ...apilogOption) *ApiLogMutation {
	m := &ApiLogMutation{
		config:        c,
		op:            op,
		typ:           TypeApiLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiLogID sets the ID field of the mutation.
func withApiLogID(id int) apilogOption {
	return func(m *ApiLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiLog
		)
		m.oldValue = func(ctx context.Context) (*ApiLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiLog sets the old ApiLog of the mutation.
func withApiLog(node *ApiLog) apilogOption {
	return func(m *ApiLogMutation) {
		m.oldValue = func(context.Context) (*ApiLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ApiLogMutation builder.
func (m *ApiLogMutation) Where(ps ...predicate.ApiLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiLog).
func (m *ApiLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiLogMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiLogMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ApiLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiLogMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ApiLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiLogMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ApiLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiLog edge %s", name)
}

// GinLogMutation represents an operation that mutates the GinLog nodes in the graph.
type GinLogMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	request_time            *time.Time
	request_host            *string
	request_path            *string
	request_query           *string
	request_method          *string
	request_scheme          *string
	request_content_type    *string
	request_body            *string
	request_client_ip       *string
	request_user_agent      *string
	request_header          *string
	request_cost_time       *int64
	addrequest_cost_time    *int64
	response_time           *time.Time
	response_header         *string
	response_status_code    *int
	addresponse_status_code *int
	response_data           *string
	go_version              *string
	sdk_version             *string
	system_info             *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*GinLog, error)
	predicates              []predicate.GinLog
}

var _ ent.Mutation = (*GinLogMutation)(nil)

// ginlogOption allows management of the mutation configuration using functional options.
type ginlogOption func(*GinLogMutation)

// newGinLogMutation creates new mutation for the GinLog entity.
func newGinLogMutation(c config, op Op, opts ...ginlogOption) *GinLogMutation {
	m := &GinLogMutation{
		config:        c,
		op:            op,
		typ:           TypeGinLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGinLogID sets the ID field of the mutation.
func withGinLogID(id int64) ginlogOption {
	return func(m *GinLogMutation) {
		var (
			err   error
			once  sync.Once
			value *GinLog
		)
		m.oldValue = func(ctx context.Context) (*GinLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GinLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGinLog sets the old GinLog of the mutation.
func withGinLog(node *GinLog) ginlogOption {
	return func(m *GinLogMutation) {
		m.oldValue = func(context.Context) (*GinLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GinLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GinLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GinLog entities.
func (m *GinLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GinLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GinLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GinLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestTime sets the "request_time" field.
func (m *GinLogMutation) SetRequestTime(t time.Time) {
	m.request_time = &t
}

// RequestTime returns the value of the "request_time" field in the mutation.
func (m *GinLogMutation) RequestTime() (r time.Time, exists bool) {
	v := m.request_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestTime returns the old "request_time" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestTime: %w", err)
	}
	return oldValue.RequestTime, nil
}

// ClearRequestTime clears the value of the "request_time" field.
func (m *GinLogMutation) ClearRequestTime() {
	m.request_time = nil
	m.clearedFields[ginlog.FieldRequestTime] = struct{}{}
}

// RequestTimeCleared returns if the "request_time" field was cleared in this mutation.
func (m *GinLogMutation) RequestTimeCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestTime]
	return ok
}

// ResetRequestTime resets all changes to the "request_time" field.
func (m *GinLogMutation) ResetRequestTime() {
	m.request_time = nil
	delete(m.clearedFields, ginlog.FieldRequestTime)
}

// SetRequestHost sets the "request_host" field.
func (m *GinLogMutation) SetRequestHost(s string) {
	m.request_host = &s
}

// RequestHost returns the value of the "request_host" field in the mutation.
func (m *GinLogMutation) RequestHost() (r string, exists bool) {
	v := m.request_host
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHost returns the old "request_host" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHost: %w", err)
	}
	return oldValue.RequestHost, nil
}

// ClearRequestHost clears the value of the "request_host" field.
func (m *GinLogMutation) ClearRequestHost() {
	m.request_host = nil
	m.clearedFields[ginlog.FieldRequestHost] = struct{}{}
}

// RequestHostCleared returns if the "request_host" field was cleared in this mutation.
func (m *GinLogMutation) RequestHostCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestHost]
	return ok
}

// ResetRequestHost resets all changes to the "request_host" field.
func (m *GinLogMutation) ResetRequestHost() {
	m.request_host = nil
	delete(m.clearedFields, ginlog.FieldRequestHost)
}

// SetRequestPath sets the "request_path" field.
func (m *GinLogMutation) SetRequestPath(s string) {
	m.request_path = &s
}

// RequestPath returns the value of the "request_path" field in the mutation.
func (m *GinLogMutation) RequestPath() (r string, exists bool) {
	v := m.request_path
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestPath returns the old "request_path" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestPath: %w", err)
	}
	return oldValue.RequestPath, nil
}

// ClearRequestPath clears the value of the "request_path" field.
func (m *GinLogMutation) ClearRequestPath() {
	m.request_path = nil
	m.clearedFields[ginlog.FieldRequestPath] = struct{}{}
}

// RequestPathCleared returns if the "request_path" field was cleared in this mutation.
func (m *GinLogMutation) RequestPathCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestPath]
	return ok
}

// ResetRequestPath resets all changes to the "request_path" field.
func (m *GinLogMutation) ResetRequestPath() {
	m.request_path = nil
	delete(m.clearedFields, ginlog.FieldRequestPath)
}

// SetRequestQuery sets the "request_query" field.
func (m *GinLogMutation) SetRequestQuery(s string) {
	m.request_query = &s
}

// RequestQuery returns the value of the "request_query" field in the mutation.
func (m *GinLogMutation) RequestQuery() (r string, exists bool) {
	v := m.request_query
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestQuery returns the old "request_query" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestQuery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestQuery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestQuery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestQuery: %w", err)
	}
	return oldValue.RequestQuery, nil
}

// ClearRequestQuery clears the value of the "request_query" field.
func (m *GinLogMutation) ClearRequestQuery() {
	m.request_query = nil
	m.clearedFields[ginlog.FieldRequestQuery] = struct{}{}
}

// RequestQueryCleared returns if the "request_query" field was cleared in this mutation.
func (m *GinLogMutation) RequestQueryCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestQuery]
	return ok
}

// ResetRequestQuery resets all changes to the "request_query" field.
func (m *GinLogMutation) ResetRequestQuery() {
	m.request_query = nil
	delete(m.clearedFields, ginlog.FieldRequestQuery)
}

// SetRequestMethod sets the "request_method" field.
func (m *GinLogMutation) SetRequestMethod(s string) {
	m.request_method = &s
}

// RequestMethod returns the value of the "request_method" field in the mutation.
func (m *GinLogMutation) RequestMethod() (r string, exists bool) {
	v := m.request_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMethod returns the old "request_method" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMethod: %w", err)
	}
	return oldValue.RequestMethod, nil
}

// ClearRequestMethod clears the value of the "request_method" field.
func (m *GinLogMutation) ClearRequestMethod() {
	m.request_method = nil
	m.clearedFields[ginlog.FieldRequestMethod] = struct{}{}
}

// RequestMethodCleared returns if the "request_method" field was cleared in this mutation.
func (m *GinLogMutation) RequestMethodCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestMethod]
	return ok
}

// ResetRequestMethod resets all changes to the "request_method" field.
func (m *GinLogMutation) ResetRequestMethod() {
	m.request_method = nil
	delete(m.clearedFields, ginlog.FieldRequestMethod)
}

// SetRequestScheme sets the "request_scheme" field.
func (m *GinLogMutation) SetRequestScheme(s string) {
	m.request_scheme = &s
}

// RequestScheme returns the value of the "request_scheme" field in the mutation.
func (m *GinLogMutation) RequestScheme() (r string, exists bool) {
	v := m.request_scheme
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestScheme returns the old "request_scheme" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestScheme(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestScheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestScheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestScheme: %w", err)
	}
	return oldValue.RequestScheme, nil
}

// ClearRequestScheme clears the value of the "request_scheme" field.
func (m *GinLogMutation) ClearRequestScheme() {
	m.request_scheme = nil
	m.clearedFields[ginlog.FieldRequestScheme] = struct{}{}
}

// RequestSchemeCleared returns if the "request_scheme" field was cleared in this mutation.
func (m *GinLogMutation) RequestSchemeCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestScheme]
	return ok
}

// ResetRequestScheme resets all changes to the "request_scheme" field.
func (m *GinLogMutation) ResetRequestScheme() {
	m.request_scheme = nil
	delete(m.clearedFields, ginlog.FieldRequestScheme)
}

// SetRequestContentType sets the "request_content_type" field.
func (m *GinLogMutation) SetRequestContentType(s string) {
	m.request_content_type = &s
}

// RequestContentType returns the value of the "request_content_type" field in the mutation.
func (m *GinLogMutation) RequestContentType() (r string, exists bool) {
	v := m.request_content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestContentType returns the old "request_content_type" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestContentType: %w", err)
	}
	return oldValue.RequestContentType, nil
}

// ClearRequestContentType clears the value of the "request_content_type" field.
func (m *GinLogMutation) ClearRequestContentType() {
	m.request_content_type = nil
	m.clearedFields[ginlog.FieldRequestContentType] = struct{}{}
}

// RequestContentTypeCleared returns if the "request_content_type" field was cleared in this mutation.
func (m *GinLogMutation) RequestContentTypeCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestContentType]
	return ok
}

// ResetRequestContentType resets all changes to the "request_content_type" field.
func (m *GinLogMutation) ResetRequestContentType() {
	m.request_content_type = nil
	delete(m.clearedFields, ginlog.FieldRequestContentType)
}

// SetRequestBody sets the "request_body" field.
func (m *GinLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *GinLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *GinLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[ginlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *GinLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *GinLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, ginlog.FieldRequestBody)
}

// SetRequestClientIP sets the "request_client_ip" field.
func (m *GinLogMutation) SetRequestClientIP(s string) {
	m.request_client_ip = &s
}

// RequestClientIP returns the value of the "request_client_ip" field in the mutation.
func (m *GinLogMutation) RequestClientIP() (r string, exists bool) {
	v := m.request_client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestClientIP returns the old "request_client_ip" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestClientIP: %w", err)
	}
	return oldValue.RequestClientIP, nil
}

// ClearRequestClientIP clears the value of the "request_client_ip" field.
func (m *GinLogMutation) ClearRequestClientIP() {
	m.request_client_ip = nil
	m.clearedFields[ginlog.FieldRequestClientIP] = struct{}{}
}

// RequestClientIPCleared returns if the "request_client_ip" field was cleared in this mutation.
func (m *GinLogMutation) RequestClientIPCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestClientIP]
	return ok
}

// ResetRequestClientIP resets all changes to the "request_client_ip" field.
func (m *GinLogMutation) ResetRequestClientIP() {
	m.request_client_ip = nil
	delete(m.clearedFields, ginlog.FieldRequestClientIP)
}

// SetRequestUserAgent sets the "request_user_agent" field.
func (m *GinLogMutation) SetRequestUserAgent(s string) {
	m.request_user_agent = &s
}

// RequestUserAgent returns the value of the "request_user_agent" field in the mutation.
func (m *GinLogMutation) RequestUserAgent() (r string, exists bool) {
	v := m.request_user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestUserAgent returns the old "request_user_agent" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestUserAgent: %w", err)
	}
	return oldValue.RequestUserAgent, nil
}

// ClearRequestUserAgent clears the value of the "request_user_agent" field.
func (m *GinLogMutation) ClearRequestUserAgent() {
	m.request_user_agent = nil
	m.clearedFields[ginlog.FieldRequestUserAgent] = struct{}{}
}

// RequestUserAgentCleared returns if the "request_user_agent" field was cleared in this mutation.
func (m *GinLogMutation) RequestUserAgentCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestUserAgent]
	return ok
}

// ResetRequestUserAgent resets all changes to the "request_user_agent" field.
func (m *GinLogMutation) ResetRequestUserAgent() {
	m.request_user_agent = nil
	delete(m.clearedFields, ginlog.FieldRequestUserAgent)
}

// SetRequestHeader sets the "request_header" field.
func (m *GinLogMutation) SetRequestHeader(s string) {
	m.request_header = &s
}

// RequestHeader returns the value of the "request_header" field in the mutation.
func (m *GinLogMutation) RequestHeader() (r string, exists bool) {
	v := m.request_header
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeader returns the old "request_header" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestHeader(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeader: %w", err)
	}
	return oldValue.RequestHeader, nil
}

// ClearRequestHeader clears the value of the "request_header" field.
func (m *GinLogMutation) ClearRequestHeader() {
	m.request_header = nil
	m.clearedFields[ginlog.FieldRequestHeader] = struct{}{}
}

// RequestHeaderCleared returns if the "request_header" field was cleared in this mutation.
func (m *GinLogMutation) RequestHeaderCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestHeader]
	return ok
}

// ResetRequestHeader resets all changes to the "request_header" field.
func (m *GinLogMutation) ResetRequestHeader() {
	m.request_header = nil
	delete(m.clearedFields, ginlog.FieldRequestHeader)
}

// SetRequestCostTime sets the "request_cost_time" field.
func (m *GinLogMutation) SetRequestCostTime(i int64) {
	m.request_cost_time = &i
	m.addrequest_cost_time = nil
}

// RequestCostTime returns the value of the "request_cost_time" field in the mutation.
func (m *GinLogMutation) RequestCostTime() (r int64, exists bool) {
	v := m.request_cost_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestCostTime returns the old "request_cost_time" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldRequestCostTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestCostTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestCostTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestCostTime: %w", err)
	}
	return oldValue.RequestCostTime, nil
}

// AddRequestCostTime adds i to the "request_cost_time" field.
func (m *GinLogMutation) AddRequestCostTime(i int64) {
	if m.addrequest_cost_time != nil {
		*m.addrequest_cost_time += i
	} else {
		m.addrequest_cost_time = &i
	}
}

// AddedRequestCostTime returns the value that was added to the "request_cost_time" field in this mutation.
func (m *GinLogMutation) AddedRequestCostTime() (r int64, exists bool) {
	v := m.addrequest_cost_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearRequestCostTime clears the value of the "request_cost_time" field.
func (m *GinLogMutation) ClearRequestCostTime() {
	m.request_cost_time = nil
	m.addrequest_cost_time = nil
	m.clearedFields[ginlog.FieldRequestCostTime] = struct{}{}
}

// RequestCostTimeCleared returns if the "request_cost_time" field was cleared in this mutation.
func (m *GinLogMutation) RequestCostTimeCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldRequestCostTime]
	return ok
}

// ResetRequestCostTime resets all changes to the "request_cost_time" field.
func (m *GinLogMutation) ResetRequestCostTime() {
	m.request_cost_time = nil
	m.addrequest_cost_time = nil
	delete(m.clearedFields, ginlog.FieldRequestCostTime)
}

// SetResponseTime sets the "response_time" field.
func (m *GinLogMutation) SetResponseTime(t time.Time) {
	m.response_time = &t
}

// ResponseTime returns the value of the "response_time" field in the mutation.
func (m *GinLogMutation) ResponseTime() (r time.Time, exists bool) {
	v := m.response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTime returns the old "response_time" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldResponseTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTime: %w", err)
	}
	return oldValue.ResponseTime, nil
}

// ClearResponseTime clears the value of the "response_time" field.
func (m *GinLogMutation) ClearResponseTime() {
	m.response_time = nil
	m.clearedFields[ginlog.FieldResponseTime] = struct{}{}
}

// ResponseTimeCleared returns if the "response_time" field was cleared in this mutation.
func (m *GinLogMutation) ResponseTimeCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldResponseTime]
	return ok
}

// ResetResponseTime resets all changes to the "response_time" field.
func (m *GinLogMutation) ResetResponseTime() {
	m.response_time = nil
	delete(m.clearedFields, ginlog.FieldResponseTime)
}

// SetResponseHeader sets the "response_header" field.
func (m *GinLogMutation) SetResponseHeader(s string) {
	m.response_header = &s
}

// ResponseHeader returns the value of the "response_header" field in the mutation.
func (m *GinLogMutation) ResponseHeader() (r string, exists bool) {
	v := m.response_header
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseHeader returns the old "response_header" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldResponseHeader(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseHeader: %w", err)
	}
	return oldValue.ResponseHeader, nil
}

// ClearResponseHeader clears the value of the "response_header" field.
func (m *GinLogMutation) ClearResponseHeader() {
	m.response_header = nil
	m.clearedFields[ginlog.FieldResponseHeader] = struct{}{}
}

// ResponseHeaderCleared returns if the "response_header" field was cleared in this mutation.
func (m *GinLogMutation) ResponseHeaderCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldResponseHeader]
	return ok
}

// ResetResponseHeader resets all changes to the "response_header" field.
func (m *GinLogMutation) ResetResponseHeader() {
	m.response_header = nil
	delete(m.clearedFields, ginlog.FieldResponseHeader)
}

// SetResponseStatusCode sets the "response_status_code" field.
func (m *GinLogMutation) SetResponseStatusCode(i int) {
	m.response_status_code = &i
	m.addresponse_status_code = nil
}

// ResponseStatusCode returns the value of the "response_status_code" field in the mutation.
func (m *GinLogMutation) ResponseStatusCode() (r int, exists bool) {
	v := m.response_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseStatusCode returns the old "response_status_code" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldResponseStatusCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseStatusCode: %w", err)
	}
	return oldValue.ResponseStatusCode, nil
}

// AddResponseStatusCode adds i to the "response_status_code" field.
func (m *GinLogMutation) AddResponseStatusCode(i int) {
	if m.addresponse_status_code != nil {
		*m.addresponse_status_code += i
	} else {
		m.addresponse_status_code = &i
	}
}

// AddedResponseStatusCode returns the value that was added to the "response_status_code" field in this mutation.
func (m *GinLogMutation) AddedResponseStatusCode() (r int, exists bool) {
	v := m.addresponse_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseStatusCode clears the value of the "response_status_code" field.
func (m *GinLogMutation) ClearResponseStatusCode() {
	m.response_status_code = nil
	m.addresponse_status_code = nil
	m.clearedFields[ginlog.FieldResponseStatusCode] = struct{}{}
}

// ResponseStatusCodeCleared returns if the "response_status_code" field was cleared in this mutation.
func (m *GinLogMutation) ResponseStatusCodeCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldResponseStatusCode]
	return ok
}

// ResetResponseStatusCode resets all changes to the "response_status_code" field.
func (m *GinLogMutation) ResetResponseStatusCode() {
	m.response_status_code = nil
	m.addresponse_status_code = nil
	delete(m.clearedFields, ginlog.FieldResponseStatusCode)
}

// SetResponseData sets the "response_data" field.
func (m *GinLogMutation) SetResponseData(s string) {
	m.response_data = &s
}

// ResponseData returns the value of the "response_data" field in the mutation.
func (m *GinLogMutation) ResponseData() (r string, exists bool) {
	v := m.response_data
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseData returns the old "response_data" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldResponseData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseData: %w", err)
	}
	return oldValue.ResponseData, nil
}

// ClearResponseData clears the value of the "response_data" field.
func (m *GinLogMutation) ClearResponseData() {
	m.response_data = nil
	m.clearedFields[ginlog.FieldResponseData] = struct{}{}
}

// ResponseDataCleared returns if the "response_data" field was cleared in this mutation.
func (m *GinLogMutation) ResponseDataCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldResponseData]
	return ok
}

// ResetResponseData resets all changes to the "response_data" field.
func (m *GinLogMutation) ResetResponseData() {
	m.response_data = nil
	delete(m.clearedFields, ginlog.FieldResponseData)
}

// SetGoVersion sets the "go_version" field.
func (m *GinLogMutation) SetGoVersion(s string) {
	m.go_version = &s
}

// GoVersion returns the value of the "go_version" field in the mutation.
func (m *GinLogMutation) GoVersion() (r string, exists bool) {
	v := m.go_version
	if v == nil {
		return
	}
	return *v, true
}

// OldGoVersion returns the old "go_version" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldGoVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoVersion: %w", err)
	}
	return oldValue.GoVersion, nil
}

// ClearGoVersion clears the value of the "go_version" field.
func (m *GinLogMutation) ClearGoVersion() {
	m.go_version = nil
	m.clearedFields[ginlog.FieldGoVersion] = struct{}{}
}

// GoVersionCleared returns if the "go_version" field was cleared in this mutation.
func (m *GinLogMutation) GoVersionCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldGoVersion]
	return ok
}

// ResetGoVersion resets all changes to the "go_version" field.
func (m *GinLogMutation) ResetGoVersion() {
	m.go_version = nil
	delete(m.clearedFields, ginlog.FieldGoVersion)
}

// SetSdkVersion sets the "sdk_version" field.
func (m *GinLogMutation) SetSdkVersion(s string) {
	m.sdk_version = &s
}

// SdkVersion returns the value of the "sdk_version" field in the mutation.
func (m *GinLogMutation) SdkVersion() (r string, exists bool) {
	v := m.sdk_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSdkVersion returns the old "sdk_version" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldSdkVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSdkVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSdkVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSdkVersion: %w", err)
	}
	return oldValue.SdkVersion, nil
}

// ClearSdkVersion clears the value of the "sdk_version" field.
func (m *GinLogMutation) ClearSdkVersion() {
	m.sdk_version = nil
	m.clearedFields[ginlog.FieldSdkVersion] = struct{}{}
}

// SdkVersionCleared returns if the "sdk_version" field was cleared in this mutation.
func (m *GinLogMutation) SdkVersionCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldSdkVersion]
	return ok
}

// ResetSdkVersion resets all changes to the "sdk_version" field.
func (m *GinLogMutation) ResetSdkVersion() {
	m.sdk_version = nil
	delete(m.clearedFields, ginlog.FieldSdkVersion)
}

// SetSystemInfo sets the "system_info" field.
func (m *GinLogMutation) SetSystemInfo(s string) {
	m.system_info = &s
}

// SystemInfo returns the value of the "system_info" field in the mutation.
func (m *GinLogMutation) SystemInfo() (r string, exists bool) {
	v := m.system_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemInfo returns the old "system_info" field's value of the GinLog entity.
// If the GinLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinLogMutation) OldSystemInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemInfo: %w", err)
	}
	return oldValue.SystemInfo, nil
}

// ClearSystemInfo clears the value of the "system_info" field.
func (m *GinLogMutation) ClearSystemInfo() {
	m.system_info = nil
	m.clearedFields[ginlog.FieldSystemInfo] = struct{}{}
}

// SystemInfoCleared returns if the "system_info" field was cleared in this mutation.
func (m *GinLogMutation) SystemInfoCleared() bool {
	_, ok := m.clearedFields[ginlog.FieldSystemInfo]
	return ok
}

// ResetSystemInfo resets all changes to the "system_info" field.
func (m *GinLogMutation) ResetSystemInfo() {
	m.system_info = nil
	delete(m.clearedFields, ginlog.FieldSystemInfo)
}

// Where appends a list predicates to the GinLogMutation builder.
func (m *GinLogMutation) Where(ps ...predicate.GinLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GinLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GinLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GinLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GinLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GinLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GinLog).
func (m *GinLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GinLogMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.request_time != nil {
		fields = append(fields, ginlog.FieldRequestTime)
	}
	if m.request_host != nil {
		fields = append(fields, ginlog.FieldRequestHost)
	}
	if m.request_path != nil {
		fields = append(fields, ginlog.FieldRequestPath)
	}
	if m.request_query != nil {
		fields = append(fields, ginlog.FieldRequestQuery)
	}
	if m.request_method != nil {
		fields = append(fields, ginlog.FieldRequestMethod)
	}
	if m.request_scheme != nil {
		fields = append(fields, ginlog.FieldRequestScheme)
	}
	if m.request_content_type != nil {
		fields = append(fields, ginlog.FieldRequestContentType)
	}
	if m.request_body != nil {
		fields = append(fields, ginlog.FieldRequestBody)
	}
	if m.request_client_ip != nil {
		fields = append(fields, ginlog.FieldRequestClientIP)
	}
	if m.request_user_agent != nil {
		fields = append(fields, ginlog.FieldRequestUserAgent)
	}
	if m.request_header != nil {
		fields = append(fields, ginlog.FieldRequestHeader)
	}
	if m.request_cost_time != nil {
		fields = append(fields, ginlog.FieldRequestCostTime)
	}
	if m.response_time != nil {
		fields = append(fields, ginlog.FieldResponseTime)
	}
	if m.response_header != nil {
		fields = append(fields, ginlog.FieldResponseHeader)
	}
	if m.response_status_code != nil {
		fields = append(fields, ginlog.FieldResponseStatusCode)
	}
	if m.response_data != nil {
		fields = append(fields, ginlog.FieldResponseData)
	}
	if m.go_version != nil {
		fields = append(fields, ginlog.FieldGoVersion)
	}
	if m.sdk_version != nil {
		fields = append(fields, ginlog.FieldSdkVersion)
	}
	if m.system_info != nil {
		fields = append(fields, ginlog.FieldSystemInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GinLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ginlog.FieldRequestTime:
		return m.RequestTime()
	case ginlog.FieldRequestHost:
		return m.RequestHost()
	case ginlog.FieldRequestPath:
		return m.RequestPath()
	case ginlog.FieldRequestQuery:
		return m.RequestQuery()
	case ginlog.FieldRequestMethod:
		return m.RequestMethod()
	case ginlog.FieldRequestScheme:
		return m.RequestScheme()
	case ginlog.FieldRequestContentType:
		return m.RequestContentType()
	case ginlog.FieldRequestBody:
		return m.RequestBody()
	case ginlog.FieldRequestClientIP:
		return m.RequestClientIP()
	case ginlog.FieldRequestUserAgent:
		return m.RequestUserAgent()
	case ginlog.FieldRequestHeader:
		return m.RequestHeader()
	case ginlog.FieldRequestCostTime:
		return m.RequestCostTime()
	case ginlog.FieldResponseTime:
		return m.ResponseTime()
	case ginlog.FieldResponseHeader:
		return m.ResponseHeader()
	case ginlog.FieldResponseStatusCode:
		return m.ResponseStatusCode()
	case ginlog.FieldResponseData:
		return m.ResponseData()
	case ginlog.FieldGoVersion:
		return m.GoVersion()
	case ginlog.FieldSdkVersion:
		return m.SdkVersion()
	case ginlog.FieldSystemInfo:
		return m.SystemInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GinLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ginlog.FieldRequestTime:
		return m.OldRequestTime(ctx)
	case ginlog.FieldRequestHost:
		return m.OldRequestHost(ctx)
	case ginlog.FieldRequestPath:
		return m.OldRequestPath(ctx)
	case ginlog.FieldRequestQuery:
		return m.OldRequestQuery(ctx)
	case ginlog.FieldRequestMethod:
		return m.OldRequestMethod(ctx)
	case ginlog.FieldRequestScheme:
		return m.OldRequestScheme(ctx)
	case ginlog.FieldRequestContentType:
		return m.OldRequestContentType(ctx)
	case ginlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case ginlog.FieldRequestClientIP:
		return m.OldRequestClientIP(ctx)
	case ginlog.FieldRequestUserAgent:
		return m.OldRequestUserAgent(ctx)
	case ginlog.FieldRequestHeader:
		return m.OldRequestHeader(ctx)
	case ginlog.FieldRequestCostTime:
		return m.OldRequestCostTime(ctx)
	case ginlog.FieldResponseTime:
		return m.OldResponseTime(ctx)
	case ginlog.FieldResponseHeader:
		return m.OldResponseHeader(ctx)
	case ginlog.FieldResponseStatusCode:
		return m.OldResponseStatusCode(ctx)
	case ginlog.FieldResponseData:
		return m.OldResponseData(ctx)
	case ginlog.FieldGoVersion:
		return m.OldGoVersion(ctx)
	case ginlog.FieldSdkVersion:
		return m.OldSdkVersion(ctx)
	case ginlog.FieldSystemInfo:
		return m.OldSystemInfo(ctx)
	}
	return nil, fmt.Errorf("unknown GinLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GinLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ginlog.FieldRequestTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestTime(v)
		return nil
	case ginlog.FieldRequestHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHost(v)
		return nil
	case ginlog.FieldRequestPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestPath(v)
		return nil
	case ginlog.FieldRequestQuery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestQuery(v)
		return nil
	case ginlog.FieldRequestMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMethod(v)
		return nil
	case ginlog.FieldRequestScheme:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestScheme(v)
		return nil
	case ginlog.FieldRequestContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestContentType(v)
		return nil
	case ginlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case ginlog.FieldRequestClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestClientIP(v)
		return nil
	case ginlog.FieldRequestUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestUserAgent(v)
		return nil
	case ginlog.FieldRequestHeader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeader(v)
		return nil
	case ginlog.FieldRequestCostTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestCostTime(v)
		return nil
	case ginlog.FieldResponseTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTime(v)
		return nil
	case ginlog.FieldResponseHeader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseHeader(v)
		return nil
	case ginlog.FieldResponseStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseStatusCode(v)
		return nil
	case ginlog.FieldResponseData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseData(v)
		return nil
	case ginlog.FieldGoVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoVersion(v)
		return nil
	case ginlog.FieldSdkVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSdkVersion(v)
		return nil
	case ginlog.FieldSystemInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemInfo(v)
		return nil
	}
	return fmt.Errorf("unknown GinLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GinLogMutation) AddedFields() []string {
	var fields []string
	if m.addrequest_cost_time != nil {
		fields = append(fields, ginlog.FieldRequestCostTime)
	}
	if m.addresponse_status_code != nil {
		fields = append(fields, ginlog.FieldResponseStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GinLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ginlog.FieldRequestCostTime:
		return m.AddedRequestCostTime()
	case ginlog.FieldResponseStatusCode:
		return m.AddedResponseStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GinLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ginlog.FieldRequestCostTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestCostTime(v)
		return nil
	case ginlog.FieldResponseStatusCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown GinLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GinLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ginlog.FieldRequestTime) {
		fields = append(fields, ginlog.FieldRequestTime)
	}
	if m.FieldCleared(ginlog.FieldRequestHost) {
		fields = append(fields, ginlog.FieldRequestHost)
	}
	if m.FieldCleared(ginlog.FieldRequestPath) {
		fields = append(fields, ginlog.FieldRequestPath)
	}
	if m.FieldCleared(ginlog.FieldRequestQuery) {
		fields = append(fields, ginlog.FieldRequestQuery)
	}
	if m.FieldCleared(ginlog.FieldRequestMethod) {
		fields = append(fields, ginlog.FieldRequestMethod)
	}
	if m.FieldCleared(ginlog.FieldRequestScheme) {
		fields = append(fields, ginlog.FieldRequestScheme)
	}
	if m.FieldCleared(ginlog.FieldRequestContentType) {
		fields = append(fields, ginlog.FieldRequestContentType)
	}
	if m.FieldCleared(ginlog.FieldRequestBody) {
		fields = append(fields, ginlog.FieldRequestBody)
	}
	if m.FieldCleared(ginlog.FieldRequestClientIP) {
		fields = append(fields, ginlog.FieldRequestClientIP)
	}
	if m.FieldCleared(ginlog.FieldRequestUserAgent) {
		fields = append(fields, ginlog.FieldRequestUserAgent)
	}
	if m.FieldCleared(ginlog.FieldRequestHeader) {
		fields = append(fields, ginlog.FieldRequestHeader)
	}
	if m.FieldCleared(ginlog.FieldRequestCostTime) {
		fields = append(fields, ginlog.FieldRequestCostTime)
	}
	if m.FieldCleared(ginlog.FieldResponseTime) {
		fields = append(fields, ginlog.FieldResponseTime)
	}
	if m.FieldCleared(ginlog.FieldResponseHeader) {
		fields = append(fields, ginlog.FieldResponseHeader)
	}
	if m.FieldCleared(ginlog.FieldResponseStatusCode) {
		fields = append(fields, ginlog.FieldResponseStatusCode)
	}
	if m.FieldCleared(ginlog.FieldResponseData) {
		fields = append(fields, ginlog.FieldResponseData)
	}
	if m.FieldCleared(ginlog.FieldGoVersion) {
		fields = append(fields, ginlog.FieldGoVersion)
	}
	if m.FieldCleared(ginlog.FieldSdkVersion) {
		fields = append(fields, ginlog.FieldSdkVersion)
	}
	if m.FieldCleared(ginlog.FieldSystemInfo) {
		fields = append(fields, ginlog.FieldSystemInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GinLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GinLogMutation) ClearField(name string) error {
	switch name {
	case ginlog.FieldRequestTime:
		m.ClearRequestTime()
		return nil
	case ginlog.FieldRequestHost:
		m.ClearRequestHost()
		return nil
	case ginlog.FieldRequestPath:
		m.ClearRequestPath()
		return nil
	case ginlog.FieldRequestQuery:
		m.ClearRequestQuery()
		return nil
	case ginlog.FieldRequestMethod:
		m.ClearRequestMethod()
		return nil
	case ginlog.FieldRequestScheme:
		m.ClearRequestScheme()
		return nil
	case ginlog.FieldRequestContentType:
		m.ClearRequestContentType()
		return nil
	case ginlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case ginlog.FieldRequestClientIP:
		m.ClearRequestClientIP()
		return nil
	case ginlog.FieldRequestUserAgent:
		m.ClearRequestUserAgent()
		return nil
	case ginlog.FieldRequestHeader:
		m.ClearRequestHeader()
		return nil
	case ginlog.FieldRequestCostTime:
		m.ClearRequestCostTime()
		return nil
	case ginlog.FieldResponseTime:
		m.ClearResponseTime()
		return nil
	case ginlog.FieldResponseHeader:
		m.ClearResponseHeader()
		return nil
	case ginlog.FieldResponseStatusCode:
		m.ClearResponseStatusCode()
		return nil
	case ginlog.FieldResponseData:
		m.ClearResponseData()
		return nil
	case ginlog.FieldGoVersion:
		m.ClearGoVersion()
		return nil
	case ginlog.FieldSdkVersion:
		m.ClearSdkVersion()
		return nil
	case ginlog.FieldSystemInfo:
		m.ClearSystemInfo()
		return nil
	}
	return fmt.Errorf("unknown GinLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GinLogMutation) ResetField(name string) error {
	switch name {
	case ginlog.FieldRequestTime:
		m.ResetRequestTime()
		return nil
	case ginlog.FieldRequestHost:
		m.ResetRequestHost()
		return nil
	case ginlog.FieldRequestPath:
		m.ResetRequestPath()
		return nil
	case ginlog.FieldRequestQuery:
		m.ResetRequestQuery()
		return nil
	case ginlog.FieldRequestMethod:
		m.ResetRequestMethod()
		return nil
	case ginlog.FieldRequestScheme:
		m.ResetRequestScheme()
		return nil
	case ginlog.FieldRequestContentType:
		m.ResetRequestContentType()
		return nil
	case ginlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case ginlog.FieldRequestClientIP:
		m.ResetRequestClientIP()
		return nil
	case ginlog.FieldRequestUserAgent:
		m.ResetRequestUserAgent()
		return nil
	case ginlog.FieldRequestHeader:
		m.ResetRequestHeader()
		return nil
	case ginlog.FieldRequestCostTime:
		m.ResetRequestCostTime()
		return nil
	case ginlog.FieldResponseTime:
		m.ResetResponseTime()
		return nil
	case ginlog.FieldResponseHeader:
		m.ResetResponseHeader()
		return nil
	case ginlog.FieldResponseStatusCode:
		m.ResetResponseStatusCode()
		return nil
	case ginlog.FieldResponseData:
		m.ResetResponseData()
		return nil
	case ginlog.FieldGoVersion:
		m.ResetGoVersion()
		return nil
	case ginlog.FieldSdkVersion:
		m.ResetSdkVersion()
		return nil
	case ginlog.FieldSystemInfo:
		m.ResetSystemInfo()
		return nil
	}
	return fmt.Errorf("unknown GinLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GinLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GinLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GinLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GinLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GinLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GinLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GinLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GinLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GinLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GinLog edge %s", name)
}

// HertzlogMutation represents an operation that mutates the Hertzlog nodes in the graph.
type HertzlogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Hertzlog, error)
	predicates    []predicate.Hertzlog
}

var _ ent.Mutation = (*HertzlogMutation)(nil)

// hertzlogOption allows management of the mutation configuration using functional options.
type hertzlogOption func(*HertzlogMutation)

// newHertzlogMutation creates new mutation for the Hertzlog entity.
func newHertzlogMutation(c config, op Op, opts ...hertzlogOption) *HertzlogMutation {
	m := &HertzlogMutation{
		config:        c,
		op:            op,
		typ:           TypeHertzlog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHertzlogID sets the ID field of the mutation.
func withHertzlogID(id int) hertzlogOption {
	return func(m *HertzlogMutation) {
		var (
			err   error
			once  sync.Once
			value *Hertzlog
		)
		m.oldValue = func(ctx context.Context) (*Hertzlog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hertzlog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHertzlog sets the old Hertzlog of the mutation.
func withHertzlog(node *Hertzlog) hertzlogOption {
	return func(m *HertzlogMutation) {
		m.oldValue = func(context.Context) (*Hertzlog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HertzlogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HertzlogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HertzlogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HertzlogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hertzlog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the HertzlogMutation builder.
func (m *HertzlogMutation) Where(ps ...predicate.Hertzlog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HertzlogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HertzlogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hertzlog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HertzlogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HertzlogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hertzlog).
func (m *HertzlogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HertzlogMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HertzlogMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HertzlogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Hertzlog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HertzlogMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hertzlog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HertzlogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HertzlogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HertzlogMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Hertzlog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HertzlogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HertzlogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HertzlogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hertzlog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HertzlogMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Hertzlog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HertzlogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HertzlogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HertzlogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HertzlogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HertzlogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HertzlogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HertzlogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Hertzlog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HertzlogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Hertzlog edge %s", name)
}
